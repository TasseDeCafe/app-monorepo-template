---
description: 
globs: 
alwaysApply: true
---
My cofounder and I are working on a language-learning app. The main idea behind the app is to help people improve their accent in many different languages. For that, we ask them to clone their voice (through 11labs' API) and we provide sentences to practice with in a language they are learning. Those sentences are generated by OpenAI's GPT API. The users are prompted to make a recording of those sentences with their real voice. The users can then listen to the same sentence pronounced by their cloned voice and compare it with their recording. The generated audio will have a close to native accent and use a voice very similar to theirs, which is useful to improve one's pronunciation. Users can click on words and sentences to play or translate them.

Users can log in via Google sign in, magic link or Apple sign in. The onboarding process consists of choosing a mother language, a study language (and sometimes also a dialect), as well as completing the voice cloning process. After this, users can generate exercises to practice their pronunciation.

We use the following stack for the app:
Landing page: Typescript React Next.js server side rendered app. We use 100% Tailwind CSS for styling.
Frontend: TypeScript React single-page application built with Vite. We use shadcn components (built on top of Radix UI) and our own components. We use 100% Tailwind CSS for styling. We use react-query for managing server state on the client. We usre redux for managing client state.
Backend: TypeScript on Node.js backend with Express framework. We use a Supabase database without an ORM, writing queries directly in the code with Postgres.js as the PostGresSQL client.
We use a couple of external APIs:
Native: Expo-managed app, using Expo Router.

- OpenAI ChatGPT completions for translations, transcriptions, and exercise generation.
- Deepgram for transcribing the user's audio into text. Deepgram also provides us with confidence scores for each word pronounced by the user.
- we use stripe api for payments on the web, and RevenueCat for the native app.
- we use resend for sending emails in the backend.
- we use elevenlabs and gpt-4o-audio for anything related to voice cloning and audio generation.

Testing: Both frontend and backend use Vitest for automated testing.

Conventions:
We use typescript across all the apps: frontend, backend, native. It's important for you to follow those conventions:
- use const for functions, don't use the "function" keyword
- use imports, not require
- in general use ecmascript, not common.js

Here are the prettier rules for code formatting:
- Trailing Commas: Use trailing commas wherever they are valid in ES5 (e.g., in objects, arrays).
- Quotes: Use single quotes for all strings.
- JSX Quotes: Use single quotes for JSX attributes.
- Semicolons: Do not use semicolons at the end of statements.

For our react code style:
- Never import React
do not do:
`export const ProgressView: React.FC = () => {`
just do:
`export const ProgressView = () => {`

- don't fix the linter errors related to incorrect alias imports.

Infrastructure:
- We use Vercel for deploying our single-page application.
- We use Supabase for hosting our remote database.
- Authentication is handled via Supabase authentication
- We use a single DigitalOcean instance for hosting our backend. Inside the instance, we run the aforementioned Express backend app with the help of PM2. We expect PM2 to safely restart the app in case of failures.
- We use Sentry for logging production bugs.

General guidelines for your answers:
- If you think that a critical file or some context is missing, ask for it before outputting your answer. Likewise, if we get stuck on a problem, it can happen that the root cause is located in a file out of the context and you can request it.
- Try not to apply "band-aid" solutions: try to fix the root cause of the problem.
- Do not hesitate to refactor the code if it fixes the root cause or simplify the code without changing the functionality.



