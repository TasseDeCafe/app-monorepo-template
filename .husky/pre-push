#!/bin/bash

# Trap signals and clean up child processes
cleanup() {
  echo ""
  echo "üõë Received interrupt signal. Cleaning up..."
  
  # Kill the entire process group (all child processes)
  # Using negative PID to target the entire process group
  pkill -P $$ 2>/dev/null || true
  
  exit 130
}

# Set up signal traps for Ctrl+C and termination
trap cleanup SIGINT SIGTERM

start_time=$(date +%s.%N)

branch=$(git rev-parse --abbrev-ref HEAD)

auto_commit_messages=()

auto_commit_changes() {
  local commit_message=$1
  shift

  if [ "$#" -gt 0 ]; then
    if git diff --quiet -- "$@"; then
      return 0
    fi
  else
    if git diff-index --quiet HEAD --; then
      return 0
    fi
  fi

  echo "üìù Detected changes for auto-commit: $commit_message"
  git add .
  if git commit -m "$commit_message" > /dev/null; then
    echo "‚úÖ Auto-commit created: $commit_message"
    auto_commit_messages+=("$commit_message")
  else
    echo "‚ùå Failed to auto-commit changes ($commit_message)"
    exit 1
  fi
}

echo "üîç Starting pre-push checks..."

if [ "$branch" = "main" ]; then
  echo "‚ùå You can't push directly to main branch."
  exit 1
fi

if ! git diff-index --quiet HEAD --; then
    echo "‚ùå Error: You have uncommitted changes. Please commit or stash them before pushing."
    exit 1
fi


# whenever we add a valid console.log( to the code we should increment this number
EXPECTED_COUNT=7

# Use git grep to search for console.log in tracked .ts and .tsx files
echo "üìä Checking console.log occurrences..."
# First count the total occurrences, excluding files in scripts directories
count=$(git grep -c "console\.log(" -- "*.ts" "*.tsx" ':!**/scripts/**' | awk -F: '{sum += $2} END {print sum}')

echo "Number of 'console.log(' occurrences: $count"

# Check if the count matches the expected count
if [ "$count" -ne "$EXPECTED_COUNT" ]; then
    echo "‚ùå Error: Expected $EXPECTED_COUNT 'console.log(' occurrences, but found $count."
    echo "üìç Locations of console.log occurrences:"
    git --no-pager grep -n "console\.log(" -- "*.ts" "*.tsx" ':!**/scripts/**'
    exit 1
else
    echo "‚úÖ Found $count 'console.log(' occurrences (matches expected: $EXPECTED_COUNT)"
fi


echo "üîÑ Fetching latest changes from remote..."
git fetch origin main

if ! git merge-base --is-ancestor main HEAD; then
  echo "‚ùå Your branch is not up-to-date with main. Please rebase or merge main into your branch before pushing."
  exit 1
else
  echo "‚úÖ Branch is up-to-date with main"
fi

# Clean Lingui catalogs so dead entries don't linger
echo "üßπ Cleaning Lingui catalogs..."
if pnpm lingui extract; then
  echo "‚úÖ Lingui catalogs updated"
else
  echo "‚ùå Lingui extract failed"
  exit 1
fi

# Translate missing translations using AI
echo "ü§ñ Translating missing translations with Claude..."
if pnpm --filter @template-app/i18n translate; then
  echo "‚úÖ Translation check completed"
else
  echo "‚ùå Translation failed"
  exit 1
fi

# Check if translation generated any changes
auto_commit_changes "chore(i18n): update translations" packages/i18n/locales

# Check if native app requires a new build using expo fingerprint
echo "üì± Checking native app fingerprint..."
fingerprint_result=0
apps/native/scripts/check-native-fingerprint.sh check || fingerprint_result=$?

if [ "$fingerprint_result" -eq 0 ]; then
  echo "‚úÖ No native build required - skipping version check"
elif [ "$fingerprint_result" -eq 1 ]; then
  echo "üî® Native build required, checking version bump..."

  # Get current versions
  current_config_version=$(grep -o "version: '[^']*'" apps/native/app.config.js | cut -d"'" -f2)
  current_package_version=$(node -p "require('./apps/native/package.json').version")

  # Check if both current versions are the same
  if [ "$current_config_version" != "$current_package_version" ]; then
    echo "‚ùå Error: Version mismatch between app.config.js and package.json!"
    echo "app.config.js version: $current_config_version"
    echo "package.json version: $current_package_version"
    echo ""
    echo "Both files must have the same version number."
    exit 1
  fi

  # Get stored version from .fingerprint file's git history (version when fingerprint was last updated)
  # We compare against main branch versions to detect if version was bumped
  main_config_version=$(git show main:apps/native/app.config.js | grep -o "version: '[^']*'" | cut -d"'" -f2)
  main_package_version=$(git show main:apps/native/package.json | node -p "JSON.parse(require('fs').readFileSync('/dev/stdin', 'utf8')).version")

  # Check if versions have been incremented
  if [ "$current_config_version" = "$main_config_version" ] || [ "$current_package_version" = "$main_package_version" ]; then
    echo "‚ö†Ô∏è  Native build required but version was not incremented!"
    echo ""
    echo "Current version: $current_config_version"
    echo ""

    # Interactive prompt
    exec < /dev/tty
    while true; do
      echo "Enter new version (or 'skip' to proceed without updating):"
      read -r new_version

      if [ "$new_version" = "skip" ]; then
        echo "‚ö†Ô∏è  Proceeding without version update..."
        break
      fi

      # Validate version format (basic semver check)
      if [[ ! "$new_version" =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
        echo "‚ùå Invalid version format. Please use semver (e.g., 1.2.3)"
        continue
      fi

      # Check that new version is different
      if [ "$new_version" = "$current_config_version" ]; then
        echo "‚ùå New version must be different from current version"
        continue
      fi

      echo ""
      echo "üîß Updating version to $new_version..."

      # Update app.config.js
      sed -i '' "s/version: '$current_config_version'/version: '$new_version'/" apps/native/app.config.js
      echo "   ‚úì Updated apps/native/app.config.js"

      # Update package.json
      cd apps/native && npm pkg set version="$new_version" && cd ../..
      echo "   ‚úì Updated apps/native/package.json"

      # Update fingerprint
      apps/native/scripts/check-native-fingerprint.sh update
      echo "   ‚úì Updated apps/native/.fingerprint"

      # Commit the changes
      git add apps/native/app.config.js apps/native/package.json apps/native/.fingerprint
      git commit -m "chore(native): bump version to $new_version"
      echo "   ‚úì Committed version bump"

      auto_commit_messages+=("chore(native): bump version to $new_version")

      echo ""
      echo "‚úÖ Version updated to $new_version"
      break
    done
  else
    echo "‚úÖ Native app version incremented ($main_config_version ‚Üí $current_config_version)"
    # Auto-update fingerprint since version was bumped
    echo "üîÑ Updating fingerprint for new version..."
    apps/native/scripts/check-native-fingerprint.sh update
    auto_commit_changes "chore(native): update fingerprint" apps/native/.fingerprint
  fi
else
  echo "‚ö†Ô∏è  Fingerprint check failed (exit code: $fingerprint_result)"
  exit 1
fi

# Run all checks through turborepo
echo "üèÉ Running all checks..."

# Check if native app (apps/native) needs environment sync
echo "‚öôÔ∏è Checking for native app changes to determine if EAS sync is needed..."
# We use 'turbo ls --affected --output=json' and jq to check if 'native' package is in the list of affected packages.
# jq's -e option sets exit status 0 if the last output value was neither false nor null.
if turbo ls --affected --output=json | jq -e '.packages.items[] | select(.name=="native")' > /dev/null; then
  echo "Syncing production environment variables on EAS for native app..."
  if pnpm sync-env; then
      echo "‚úÖ Environment sync passed"
  else
      echo "‚ùå Environment sync failed"
      exit 1
  fi
else
  echo "Skipping EAS environment sync as native app is not affected by these changes."
fi

cd apps/backend
pnpm check-migrations
cd ../..

cd apps/backend
pnpm check-templates
cd ../..

echo "Running lint..."
if pnpm lint; then
    echo "‚úÖ Lint passed"
else
    echo "‚ùå Lint failed"
    exit 1
fi

# Check if lint --fix generated any changes
auto_commit_changes "style: apply eslint auto-fixes"

echo "Checking types..."
if pnpm check:types; then
    echo "‚úÖ Types check passed"
else
    echo "‚ùå Types check failed"
    exit 1
fi

echo "Running tests..."
if pnpm test:run; then
    echo "‚úÖ Tests passed"
else
    echo "‚ùå Tests failed"
    exit 1
fi

echo "Building..."
if pnpm build; then
    echo "‚úÖ Build passed"
else
    echo "‚ùå Build failed"
    exit 1
fi

echo "‚úÖ Pre-push script executed successfully."

if [ ${#auto_commit_messages[@]} -gt 0 ]; then
  echo ""
  echo "‚ÑπÔ∏è The hook auto-committed the following changes:"
  for message in "${auto_commit_messages[@]}"; do
    echo "   ‚Ä¢ $message"
  done
  echo "Please run 'git push' again to include these commits in the remote."
fi

end_time=$(date +%s.%N)
execution_time=$(echo "$end_time - $start_time" | bc)
echo -e "\nScript execution time: ${execution_time} seconds"

exit 0
