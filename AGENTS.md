My cofounder and I are working on a language-learning app. The main idea behind the app is to help people improve their accent in many different languages. For that, we ask them to clone their voice (through 11labs' API) and we provide sentences to practice with in a language they are learning. Those sentences are generated by OpenAI's GPT API. The users are prompted to make a recording of those sentences with their real voice. The users can then listen to the same sentence pronounced by their cloned voice and compare it with their recording. The generated audio will have a close to native accent and use a voice very similar to theirs, which is useful to improve one's pronunciation. Users can click on words and sentences to play or translate them.

Users can log in via Google sign in, magic link or Apple sign in. The onboarding process consists of choosing a mother language, a study language (and sometimes also a dialect), as well as completing the voice cloning process. After this, users can generate exercises to practice their pronunciation.

We use the following stack for the app:
Landing page: Typescript React Next.js server side rendered app. We use 100% Tailwind CSS for styling.
Frontend: TypeScript React single-page application built with Vite. We use shadcn components (built on top of Radix UI) and our own components. We use 100% Tailwind CSS for styling. We use react-query for managing server state on the client. We usre redux for managing client state.
Backend: TypeScript on Node.js backend with Express framework. We use a Supabase database without an ORM, writing queries directly in the code with Postgres.js as the PostGresSQL client.
We use a couple of external APIs:
Native: Expo-managed app, using Expo Router.

- OpenAI ChatGPT completions for translations, transcriptions, and exercise generation.
- Deepgram for transcribing the user's audio into text. Deepgram also provides us with confidence scores for each word pronounced by the user.
- we use stripe api for payments on the web, and RevenueCat for the native app.
- we use resend for sending emails in the backend.
- we use elevenlabs and gpt-4o-audio for anything related to voice cloning and audio generation.

Testing: Both frontend and backend use Vitest for automated testing.

# Conventions:

We use typescript across all the apps: frontend, backend, native. It's important for you to follow those conventions:

- use const for functions, don't use the "function" keyword
- use imports, not require
- in general use ecmascript, not common.js

Here are the prettier rules for code formatting:

- Trailing Commas: Use trailing commas wherever they are valid in ES5 (e.g., in objects, arrays).
- Quotes: Use single quotes for all strings.
- JSX Quotes: Use single quotes for JSX attributes.
- Semicolons: Do not use semicolons at the end of statements.

For our react code style:

- Never import React
  do not do:
  `export const ProgressView: React.FC = () => {`
  just do:
  `export const ProgressView = () => {`

- don't fix the linter errors related to incorrect alias imports.

# Infrastructure:

- We use Vercel for deploying our single-page application.
- We use Supabase for hosting our remote database.
- Authentication is handled via Supabase authentication
- We use a single DigitalOcean instance for hosting our backend. Inside the instance, we run the aforementioned Express backend app with the help of PM2. We expect PM2 to safely restart the app in case of failures.
- We use Sentry for logging production bugs.

# General guidelines for your answers:

- If you think that a critical file or some context is missing, ask for it before outputting your answer. Likewise, if we get stuck on a problem, it can happen that the root cause is located in a file out of the context and you can request it.
- Try not to apply "band-aid" solutions: try to fix the root cause of the problem.
- Do not hesitate to refactor the code if it fixes the root cause or simplify the code without changing the functionality.
- Do not write code that is backwards compatible unless explicitly asked to do so. Assume that the code is not yet in production

## Localization pattern (Lingui)

- Default to Lingui for every user-facing text. Never ship raw strings; wrap them with `t`` template literals as soon as you add copy.
- In React components or hooks, import `useLingui` and call it near the top (`const { t, i18n } = useLingui()`). Use `t``Text`` in JSX/TS, and call `i18n._(messageDescriptor)` for shared descriptor maps like `langNameMessages`.
- Outside React (e.g., config files, query meta, utility modules), import `{ t }` from `@lingui/macro` and, when needed, the shared `i18n` instance for lookups. Keep text in template literals so translators see the full sentence.
- When interpolating values, assign them to descriptive variables and reference them inside the template literal (`const savedCount = ...; t`You saved ${savedCount} phrases``). Avoid string concatenation or unnamed `${expression}` chains.
- Do not set custom ids when calling `t`. The English source string remains the id so extraction keeps working without manual bookkeeping.

# Useful commands:

- Check typing with TS: pnpm check:types (executed from the root directory)
- Check linting with ESLint: pnpm lint (executed from the root directory)

# comments

Rules:

- it's ok to put comments above big chunks of JSX in react components, this way we do not need to extract too many components
- try why you did something rather than what and how you did it
- add links to docs above tickets, if you're using a third party docs
  example:

```node
 // based on https://elevenlabs.io/docs/api-reference/twilio/outbound-call
 export const initiateCancelCallViaTwilio = async (
```
